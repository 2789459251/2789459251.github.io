[{"title":"Docker操作","url":"/2024/01/15/Docker%E6%93%8D%E4%BD%9C/","content":"1.简介\n广义上：\n  虚拟化的技术。下载完就使用。将环境变量配置好了。\n\n优势在于：\n\n\n更高效的利用系统资源；容器不需要硬件虚拟，运行系统的额外开销\n更快启动时间；\n一致的运行环境；\n持续的交付和部署。\n更轻松的迁移。\n更轻松的维护和扩展。（分层存储、镜像）\n\n实际上：\n\n是容器\n\n与传统虚拟机比较：\n\n\n\n镜像与容器：\n  用户基于镜像来运行容器。镜像是Docker生命周期的“构建”、“打包”部分。\n  理解：镜像是类,容器是对象\n  容器放置服务基于镜像启动，运行一个多个进程。容器像是Docker生命周期的“启动”“执行”\n\n\n\n2.常用命令\n镜像：\n\n\n\n容器\n\n\n守护方式创建容器后，进入容器命令行的指令：\ndocker exec -it myubuntu1 &#x2F;bin&#x2F;bash\n守护方式运行容器，即使退出，容器仍然运行。\ndocker stop +id&#x2F;name停止。\ndocker start +id&#x2F;name开始。\n\n删除镜像：rmi\n删除容器：rm\n\nmysql的部署：\n先拉取5.7版本的mysql镜像docker pull mysql:5.7\ndocker  run -di  - -name&#x3D;xxx -p 3306:3306  -e MYSQL_ROOT_PASSWORD&#x3D;root mysql:5.7(顺便配置了一波密码\n\n\n\n\n\nnginx的部署：\n拉取docker pull nginx\n映射：docker run -di - -name&#x3D;nginx -p80:80 nginx\n拷贝：docker cp &#x2F;etc&#x2F;nginx:&#x2F;usr&#x2F;local&#x2F;mytry—&gt;改名mv nginx conf\n挂载：docker  run -di - -name&#x3D;nginx -p 80:80 -v &#x2F;usr&#x2F;local&#x2F;mytry&#x2F;conf&#x2F;:&#x2F;etc&#x2F;nginx nginx\n\n\nredis的部署：\n拉取\n运行容器 同上不过p:6379\n\ndocker ps：运行的容器\ndocker ps -a：所有容器\n","tags":["docker"]},{"title":"Git操作合辑","url":"/2024/01/15/Git%E6%93%8D%E4%BD%9C%E5%90%88%E8%BE%91/","content":"1.版本控制\n认知\n\n备份和记录\n\n演变过程：\n\n本地版本控制系统（不利于合作开发）\n\n集中化版本控制系统cvcs（服务器挂机就无法使用，硬盘坏了会丢失数据）—单点故障\n\n\n\n\n分布式版本控制系统dvcs（解决单点故障）\n\n\n2.安装已经安装了不在赘述，官网下载安装即可。\n\n配置：\n\n\n\ngit文件状态：\n\ngit的三个工作区域：\n\n\n\n\ngit工作流程：\n\n\n3.创建版本库提交文件\ngit init\ngit add 文件\ngit commit -m “说明”\n\n但是遇到问题了：\n\n\n\nsudo nano .git&#x2F;config :\n\n[user]\n  name &#x3D; 2789459251\n  email &#x3D; “18291734409@stu.xupt.edu.cn“\n\n其他命令：\n\ngit status：查看版本库状态\ngit log：操作日志\n4.时光穿梭修改文件与文件提交\ngit add 文件\ngit commit -m “说明”\ngit reset HEAD:暂存区文件撤销操作\ngit log -5 —pretty&#x3D;oneline log的简化输出指令\n\n版本回退\ngit reset - -hard HEAD^ 退回上个版本（回退几个版本就加几个^）\n\ncat s：看工作目录的文件内容。 \n\ngit reset - - hard HEAD~[数字]：回退[数字]个版本。\n\n到未来版本：\n\ngit reset –hard 83fad5ea8ff31208c4cef8909e809f8e039d3623\n\n\n问题：到第三个版本后\n\ngit log -5 —pretty&#x3D;oneline看不到版本4、5的id了\ngit reflog &#x2F;&#x2F;可以看HEAD历史的指向变化\n再使用\ngit reset - -hard id\n\n文件删除在工作区删除不影响git仓库\n误删恢复：git checkout - - 文件名\n从本地仓库拷贝到工作区\n从本地仓库和工作区删除：git rm  文件名\n\n但还是可以通过版本回退来恢复。\n5.远程仓库github,码云等，代码托管平台。\n1.克隆git clone网址\n2.推送\nhttps与ssh(加密推送)\n公钥秘钥生成命令：\n\n然后再在对应目录找到公钥，添加到github账户。\n检查连接：\n\n我遇到了权限问题！！！\n解决方法 ：\n\n操作：sudo git remote add origin &#103;&#x69;&#116;&#64;&#x67;&#105;&#x74;&#104;&#117;&#98;&#46;&#99;&#x6f;&#x6d;:2789459251&#x2F;gitsshtext.git \n      sudo -E git push -u origin master\n\n\n6.分支本地操作本地分支指令如下：\n\n远程操作：push和pull\n\n分支操作冲突出现与解决：\n开发中对不同分支下同一文件进行修改后执行合并会出现文件修改冲突\n\n手动修改就行；\n远程分支冲突：git pull\n先拉取再推送；（就可以避免很多冲突）\n依旧需要手动修改。\n\n 拉取，修改，添加，提交，推送。\n\n7.标签管理相当于：正式发行版本\n\n\n重要的命令：git pull ssh地址 分支名\n将数据down下来\n","tags":["git命令"]},{"title":"golang框架","url":"/2024/01/15/golang%E6%A1%86%E6%9E%B6/","content":"\nGin关于web关于HTTP协议进行交互的应用网络\n通过使用浏览器访问各种资源\n四种请求方法\n\nRESTful风格代码\n\n模版与渲染提前准备模版，渲染的作用机制类似于文本替换操作。\n使用：\n1.定义模版→2.解析模版→3.渲染模版\n\n模版语法.的用法\n注释：\npipeline：传递数据\n定义变量：！！！\n移除空格\n条件判断\n\nlt:小于\n\n\n自定义模版函数注意文件名字需要一模一样\n\n嵌套模版：\n\n模版继承：\n\n![](https://secure2.wostatic.cn/static/j643ZnfMKXxHMErBg6fyXt/截图%202023-11-08%2000-52-18.png?auth_key=1705332349-hRGXp8zaAmTJvTaM9P81Dd-0-c557b6994fa6f934d315442969\n模版补充：\n1.修改模版默认的标识符\n","tags":["gin json"]},{"title":"kafka消息队列","url":"/2024/01/15/kafka%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/","content":"一、入门kafka\n传统定义分布式的基于发布的&#x2F;订阅模式的消息队列\n\n\n\n\ngo操作kafka,导包，上网搜。\n\n\n分区：config.Producer.Partition &#x3D; sarama.NewHashPartitioner\n\nconfig.Consumer.partationner\n","tags":["消息队列"]},{"title":"微服务","url":"/2024/01/15/%E5%BE%AE%E6%9C%8D%E5%8A%A1/","content":"grpcproto约束文件介绍命令\nmessage关键字相当于golang里的结构体\n\n 字段规则\n\nrepeated:代表切片等可重复类型\noptions：其他默认是options\n\n 消息号\n\nmessage中每个字段必须有一个唯一标识号\n服务定义`rpc 服务函数名()returns()`\n\n服务端编写\n 写服务端实际的服务逻辑\n 创建grpcserver对象→server端的抽象对象\n 将编写的服务注册到grpcserver中\n 创建listen，grpcserver启动服务，listen监听server端口\n\n客户端编写\n grpc连接到server端，加密认证\n 获得与server端连接的客户端\n 客户端执行rpc调用\n\n认证-安全传输多个server与client之间的认证\n\nSSL&#x2F;TSL认证\nToken认证\n不安全连接\n自定义身份认证\n\n加入证书，实现安全调用\nhttps://www.kuangstudy.com/bbs/1604044550878703617\n认证方式\nSSL&#x2F;TLS认证命令：生成私钥openssl genrsa -out server.key 2048生成证书openssl req -new -x509 -key server.key -out server.crt -days 36500(有效期)生成证书签名请求文件openssl req -new -key server.key -out server.csr修改配置文件    cp openssl.cnf key    copy_extensions = copy    req_extensions = v3_req # The extensions to add to a certificate request    [ v3_req ]中添加 subjectAltName = @alt_names    添加标签：[alt_names]DNS.1=*.zy.com=》只有这个域名可以访问到代码生成证书私钥test.key    openssl genpkey -algorithm RSA -out test.key生产证书请求文件test.csr openssl req -new -nodes -key test.key -out test.csr -days 3650 -subj &quot;/C=cn/OU=myorg/O=mycomp/CN=myname&quot; -config ./openssl.cnf -extensions v3_req生成SAN证书pemopenssl x509 -req -days 365 -in test.csr -out test.pem -CAserver.crt -CAcreateserial -extfile ./openssl.cnf -extensions v3_req改正版命令：sudo openssl x509 -req -days 365 -in test.csr -out test.pem-CA /usr/local/sdk/go/src/hello/key/server.crt-CAkey /usr/local/sdk/go/src/hello/key/server.key-CAcreateserial -extfile ./openssl.cnf -extensions v3_req\n\n认证生成私钥证书文件命令在hello-server key 命令.txt文件中\n\n server端传入.key文件，.pem文件生成证书\n 在创建grpcserver时将证书塞进去\n client端传入.pem文件和域名生成证书\n 再获得conn连接时，塞入证书\n\nToken认证\n 将客户端实现有关Token的接口：GetRequestMetadata →返回携带信息，RequireTransportSecurity→是否开启ssl\n 客户端获得携带ssl与token的切片\n server端在服务（不推荐）或者拦截器中校验token令牌\n\n可以与SSL&#x2F;TLS结合\ngo-zero基础简介微服务将大系统按照功能或者产品进行服务拆分→独立的服务\n服务间通信→rpc通信连接\n准备工具Etcd\n→是什么：etcd是一个高可用的分布式键值存储系统。采用Raft一致性算法保证数据的强一致性，并支持对数据进行监听更新。→用途：微服务的配置中心，服务发现\n→理解：数据可靠性更强，加强版redis\netcd的基本命令  1.etcdctl put name zy  2.etcdctl get name-&gt;返回键值对  3.etcdctl get name --print-value-only-&gt;只希望返回值  4.etcdctl get na --prefix-&gt;返回前缀符合条件的键值对  5.etcdctl watch name-&gt;监听键的变化  6.etcdctl del name-&gt;删除键\n\n命令：\nzsy@zsy-21CY:/usr/local/sdk/go/src/zero-study/user/rpc$ goctl rpc protoc user.proto --go_out=types --go-grpc_out=types --zrpc_out=.\n\n goctl api go -api video&#x2F;api&#x2F;video.api -dir video&#x2F;api&#x2F;\n\napi服务api go -api xxx.api -dir .\n\napi语法syntax &#x3D; “v1”\ntype :类似于结构体→请求体、响应体、实例\n\n支持结构体嵌套和引用\n\nservice:定义微服务\n\n@handler 方法名\n请求方法 路由 请求、响应\n\n@server():控制对http服务生成时meta信息\n\ngroup:路由分组目录\nprefix:路由前缀\njwt:鉴权Auth 值为 jwt 密钥，过期   等信息配置的 golang 结构体名称\n\n\n在user.yaml中配置秘钥与过期时间\n\n\nmiddleware:中间件\ntimeout:3s超时控制，值为 time.Duration \nmaxBytes: 最大请求控制\n\napi封装避免重复写响应体的重复字段信息。我们可以将 code 和 msg 抽象在 base.api 中，然后 user.api 中复用和定义具体的响应结构体即可。\nhttp服务→main.api→引入没有service块的api\n结构体→xxx.api\napi命令goctl api new demogoctl api go -api xxx.api -dir. \n\n类似的proto文件生成代码命令：\ngoctl rpc new demo\n\n但rpc需要在配置文件中添加代码\n`etc/demo.yaml：`Name: demo.rpcListenOn: 0.0.0.0:8080Mode: dev\n\napi格式化命令：\ngoctl api format —dir demo.api\n\njwt鉴权实现\n@server(jwt:Auth)\n在xxx.yaml文件中配置秘钥以及有效期\n在公共目录中完成jwt的签发逻辑\nlogin后获得jwt签发的token，并返回\n在main函数中加入鉴权失败的回调函数，说明鉴权失败的原因。\n\n操作mysql生成model代码goctl model mysql ddl —src xx.sql —dir .(有表)\n\n→自动加入了增删改的代码\n→也可以自己添加手写sql\nmodel代码使用\n再config写上mysql配置→数据源\n在xxx.yaml文件中配置数据源\n在svn包里的创建mysql连接\n登录逻辑中可以查询数据库了\n\n结合gorm→开发更加高效\n\n在models创建type,引入gorm.Model（直接编写model文件）\n在common中加入初始化gorm的代码\nconfig.go中不变\nsvc中连接mysql\nlogin逻辑中使用gorm\n\nrpc服务单rpc服务模式编写一个proto文件在service块添加rpc→通过命令[goctl rpc protoc user.proto –go_out&#x3D;.&#x2F;types –go-grpc_out&#x3D;.&#x2F;types –zrpc_out&#x3D;.]生成对应的文件，其中rpc文件生成在types文件夹中→补充逻辑就行了\n服务分组proto文件在不同的service块放不同的rpc服务→在命令后面加上-m\n结合gormproto文件→命令→配置文件.yaml文件添加mysql数据库信息→config.go添加mysql映射→svc依赖注入mysql,初始化连接数据库→补充逻辑\n结合apiapi文件→命令goctl api go -api user.api -dir .\n配置文件里写rpc服务的key→填写配置文件→svc依赖注入rpc客户端→逻辑写一下。\n","tags":["grpc go_zero"]},{"title":"项目实践","url":"/2024/01/15/%E9%97%AE%E9%A2%98%E5%90%88%E8%BE%91/","content":"问题合辑1.nmp和node不能全局应用\n\n第一种安装方法：\n\n  卸载原有的手动安装的所有:sudo rm -rf &#x2F;usr&#x2F;local&#x2F;node-v21.5.0-linux-x64&#x2F;\n  重新安装sudo apt update,sudo apt install nodejs npm\n  有问题就sudo apt install -f,sudo apt autoremove,sudo apt install nodejs npm\n\n第二种安装方法：\n进入官网https://nodejs.org/en下载最新版\nsudo tar -xvf  xxxxxxxxx.tar.xz\ncd xxxxxxxxx\nsudo cp -R * &#x2F;usr&#x2F;bin\n建立软连接(→)\nsudo ln -s &#x2F;usr&#x2F;local&#x2F;bin&#x2F;npm &#x2F;usr&#x2F;bin&#x2F;npm&#x2F;\nsudo ln-s &#x2F;usr&#x2F;local&#x2F;bin &#x2F;node &#x2F;usr&#x2F;bin&#x2F;node&#x2F;\n确保usr&#x2F;local&#x2F;bin&#x2F;在环境变量中\necho $PATH\nexport PATH&#x3D;$PATH:usr&#x2F;local&#x2F;bin&#x2F;\n\n\n2.后端启动报错：\n\nerror obtaining VCS status: exit status 128\nUse -buildvcs&#x3D;false to disable VCS stamping.\n这次的问题是仓库有一些修改尚未提交，提交到与远程仓库就好了\n\n\n3.为什么我的git命令前都需要加sudo\n仓库的所有人是root\n\nsudo chown -R 1000:1000 仓库目录\n\n4.推送git push时远程仓库拒绝连接\n\ngit remote set-url origin ssh连接\n如果ssh连接没有建立好需要：确定代理正在运行并且包含我的秘钥\neval “$(ssh-agent -s)”\n\n\nssh-add -l\n  这时你也有可能没有生成秘钥，那就需要执行生成秘钥\n  ssh-keygen -t ed25519 -C “&#50;&#x37;&#x38;&#57;&#52;&#53;&#56;&#88;&#88;&#x58;&#x40;&#113;&#x71;&#x2e;&#99;&#111;&#x6d;“\n  ssh-add ~&#x2F;.ssh&#x2F;id_ed25519\n  将生成的公钥(~&#x2F;.ssh&#x2F;id_ed25519.pub)添加到github\n  运行以下命令将 SSH Agent 配置添加到 Git：\n  git config –global core.sshCommand “ssh -v -i ~&#x2F;.ssh&#x2F;id_ed25519 -o ‘StrictHostKeyChecking&#x3D;no’ -o ‘UserKnownHostsFile&#x3D;&#x2F;dev&#x2F;null’”\n  “不能锁定配置文件 &#x2F;home&#x2F;zsy&#x2F;.gitconfig: 权限不够” 的错误表明你的用户没有足够的权限修改全局的 Git 配置文件\n  手动编辑~&#x2F;.gitconfig添加\n  [core]\nsshCommand = ssh -v -i ~/.ssh/id_ed25519 -o &#39;StrictHostKeyChecking=no&#39; -o &#39;UserKnownHostsFile=/dev/null&#39;\n\n5.在github上有两个差异过大的分支想要合并\n\n只能手动git\n创建一个空的本地仓库 git init\ngit clone xxxx.git\ncd 本地仓库\ngit merge origin master —allow-unrelated-hestories\ngit add .\ngit merge —continue\ngit commit -m “”\ngit push origin main\ngit push origin —delete master\n\n\n"}]